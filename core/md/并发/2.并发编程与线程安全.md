#### 1. 环境搭建
```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.1.5.RELEASE</version>
    <relativePath/> <!-- lookup parent from repository -->
  </parent>
  <groupId>org.stud</groupId>
  <artifactId>thread-saif</artifactId>
  <version>1.0-SNAPSHOT</version>

  <properties>
    <java.version>1.8</java.version>
  </properties>

  <dependencies>
    <!--<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
    </dependency>-->
    <!--<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>-->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--<dependency>
      <groupId>org.mybatis.spring.boot</groupId>
      <artifactId>mybatis-spring-boot-starter</artifactId>
      <version>2.0.1</version>
    </dependency>-->

    <!--<dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <scope>runtime</scope>
    </dependency>-->
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <optional>true</optional>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>

</project>
```

#### 2 线程安全性
  > 多线程和单线程的一致结果。
  
  #### 2.1 原子性
  - AtomicInteger[代表]  
    Unsafe.compareAndSwapInt(***核心CAS)：拿当前的值和底层的值做比饺，如果一致才会做对应的操作。
     
  - AtomicLong和LongAdder(java8)区别：
    
  - AtomicIntegerFieldUpdater、AtomicReference
    
  - CAS的ABA问题
  
  #### 2.2 锁
  - synchronized： 不可中断锁，社訸竞争不激烈，可读性好。
  - Lock： 可中断锁，多样化同步，竞争激烈时能维持常态。
  - Atomic: 竞争激烈时能维持常态，比lock性能好；只能同步一个值;
  
  #### 2.3 可见性
  导致共享变量在线程间的不可见原因：
  - 线程交叉执行
  - 重排序结合线程交叉执行
  - 共享变量更新后的值没有在工作内存与主存间及时更新
  
  ##### 2.3.1 synchronized
  - 线程解锁前，必须把共享变量的值刷新到主内存
  - 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存钟重新读取最新的值（注意，加锁与解锁是同一把锁）
  ##### 2.3.2 volatile
  通过加入内存屏障和禁止重排序优化来实现
  - 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存中。
  - 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。
  
  > ++ 或者 -- 会被拆为三步，所以不是原子操作。volatile修饰是无效的。
  
  ##### 2.3.3 有序性 - happens-before原则
  
  - 程序次序规则： 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。
  - 锁定规则： 一个unlock操作先行发生于后面对同一个锁的lock操作
  
  补充
  
  #### 发布对象
  
   
  
  
  
  
  
  