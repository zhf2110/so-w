#### ArrayList -> CopyOnWriteArrayList
  - 缺点：
     1.内存占有问题:很明显，两个数组同时驻扎在内存中，如果实际应用中，数据比较多，而且比较大的情况下，占用内存会比较大，针对这个其实可以用ConcurrentHashMap来代替。
     
     2.数据一致性:CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器
  - 优先：
     1. 最终一致性
     2. 读写分离
     3. 会生成一个新的容器，将数据写入后，返回新的引用。
     
  
   ```
   @Slf4j
   public class CopyOnWriteExample {
   
   
   	private final CopyOnWriteArrayList<String> stroe = new CopyOnWriteArrayList<>();
   
   	private void init(){
   		for(int i = 0 ;i < 100;i ++){
   			stroe.add("xxxx"+i);
   		}
   	}
   
   	private void read(){
   		int loop = 200;
   		for(int i = 0;i < loop;i ++){
   			log.info(" read : {}",stroe.get(i));
   		}
   	}
   
   
   	private void write(String va){
   		stroe.add(va);
   	}
   
   
   	public static void main(String[] args) {
   		final CopyOnWriteExample example = new CopyOnWriteExample();
   		example.init();
   		ExecutorService service = Executors.newCachedThreadPool();
   		service.execute(()->{
   			example.read();
   		});
   
   		service.execute(()->{
   			for(int i= 0;i < 100;i ++){
   				example.write("yyyy"+i);
   			}
   		});
   	}
   
   }
   ```
   分析其中的add和get源码
   ```
   public boolean add(E e) {
           final ReentrantLock lock = this.lock; //获得可重入锁
           lock.lock();
           try {
               Object[] elements = getArray(); //获得当前的数组
               int len = elements.length;
               Object[] newElements = Arrays.copyOf(elements, len + 1); //将当前的数组复制到一个新的数组中
               newElements[len] = e; //添加新元素
               setArray(newElements); //将当前新的数组的应用返回，替换之前的引用
               return true;
           } finally {
               lock.unlock();
           }
       }
   ```
   
   ```
   public E get(int index) {
           return get(getArray(), index); //直接从当前的数组中返回
       }
  
   ```
   
   
#### HashSet、TreeSet -> CopyOnWriteArraySet、ConcurrentSkipListSet（线程安全部分）
   - CopyOnWriteArraySet 底层是通过CopyOnWriteArrayList实现的，唯一的判断过程如下源码：
   ```
    public boolean addIfAbsent(E e) {
           Object[] snapshot = getArray(); //获得当前的数据
           return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :
               addIfAbsent(e, snapshot);
       }
       
    /***
      1 . 循环查询数组中是否与此对象一致的对象。注意：如果对象需要重写equals方法
      2 . 没有则添加
    ***/
    private static int indexOf(Object o, Object[] elements,
                                   int index, int fence) {
            if (o == null) {
                for (int i = index; i < fence; i++)
                    if (elements[i] == null)
                        return i;
            } else {
                for (int i = index; i < fence; i++)
                    if (o.equals(elements[i]))
                        return i;
            }
            return -1;
        }
     
     /**
       1. 会判断当前的数组有没有被修改，没有则直接创建一个比当前容器大一的容器，赋值，重定引用
       2. 如果已被修改判断是否是新增成功，如果已经执行则返回false，如果容器被其他操作执行，检查当前容器中是否已存在当前值。
     ***/
     private boolean addIfAbsent(E e, Object[] snapshot) {
            final ReentrantLock lock = this.lock;
            lock.lock();
            try {
                Object[] current = getArray();
                int len = current.length;
                if (snapshot != current) {
                    // Optimize for lost race to another addXXX operation
                    int common = Math.min(snapshot.length, len);
                    for (int i = 0; i < common; i++)
                        if (current[i] != snapshot[i] && eq(e, current[i]))
                            return false;
                    if (indexOf(e, current, common, len) >= 0)
                            return false;
                }
                Object[] newElements = Arrays.copyOf(current, len + 1);
                newElements[len] = e;
                setArray(newElements);
                return true;
            } finally {
                lock.unlock();
            }
        }
   ```
   - ConcurrentSkipListSet 的底层实现为ConcurrentSkipListMap
   
#### HashMap、TreeMap -> ConcurrentHashMap、ConcurrentSkipListMap
   
#### AQS(AbstractQueuedSynchronizer 抽象类)核心

- 基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架
- 该同步器（以下简称同步器）利用了一个int来表示状态
- 此子类对于状态的把握，需要使用这个同步器提供的以下三个方法对状态进行操作：
  ```
  java.util.concurrent.locks.AbstractQueuedSynchronizer.getState()
    java.util.concurrent.locks.AbstractQueuedSynchronizer.setState(int)
    java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(int, int)
  ```
- 该同步器即可以作为排他模式也可以作为共享模式，当它被定义为一个排他模式时，其他线程对其的获取就被阻止，而共享模式对于多个线程获取都可以成功
  
  思路：
    
    
    
##### CountDownLatch
```
public static void main(String[] args) {
		final CountDownLatch countDownLatch = new CountDownLatch(2);
		
		ExecutorService service = Executors.newCachedThreadPool();

		for(int i = 0;i < 5;i++){
			service.execute(()->{
				try {
					Thread.sleep((int)Math.random()*1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				log.info(" 线程id为： {}",Thread.currentThread().getId());
				countDownLatch.countDown();
			});
		}

		try {
			countDownLatch.await();
			/**
			 * 等待时间，如果任务10秒内没有完成，则不再关心。
			 */
			//countDownLatch.await(10, TimeUnit.SECONDS);
			log.info("ok");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		service.shutdown();
	}
```
 上面的案例说明，将有五个子任务需要执行，但是需要前两个先执行，等执行完后，后面的才会执行。
 

##### Semaphore 信号量

   - 控制访问数量
   