#### ArrayList -> CopyOnWriteArrayList
  - 缺点：
     1.内存占有问题:很明显，两个数组同时驻扎在内存中，如果实际应用中，数据比较多，而且比较大的情况下，占用内存会比较大，针对这个其实可以用ConcurrentHashMap来代替。
     
     2.数据一致性:CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器
  - 优先：
     1. 最终一致性
     2. 读写分离
     3. 会生成一个新的容器，将数据写入后，返回新的引用。
     
  
   ```
   @Slf4j
   public class CopyOnWriteExample {
   
   
   	private final CopyOnWriteArrayList<String> stroe = new CopyOnWriteArrayList<>();
   
   	private void init(){
   		for(int i = 0 ;i < 100;i ++){
   			stroe.add("xxxx"+i);
   		}
   	}
   
   	private void read(){
   		int loop = 200;
   		for(int i = 0;i < loop;i ++){
   			log.info(" read : {}",stroe.get(i));
   		}
   	}
   
   
   	private void write(String va){
   		stroe.add(va);
   	}
   
   
   	public static void main(String[] args) {
   		final CopyOnWriteExample example = new CopyOnWriteExample();
   		example.init();
   		ExecutorService service = Executors.newCachedThreadPool();
   		service.execute(()->{
   			example.read();
   		});
   
   		service.execute(()->{
   			for(int i= 0;i < 100;i ++){
   				example.write("yyyy"+i);
   			}
   		});
   	}
   
   }
   ```
   分析其中的add和get源码
   ```
   public boolean add(E e) {
           final ReentrantLock lock = this.lock; //获得可重入锁
           lock.lock();
           try {
               Object[] elements = getArray(); //获得当前的数组
               int len = elements.length;
               Object[] newElements = Arrays.copyOf(elements, len + 1); //将当前的数组复制到一个新的数组中
               newElements[len] = e; //添加新元素
               setArray(newElements); //将当前新的数组的应用返回，替换之前的引用
               return true;
           } finally {
               lock.unlock();
           }
       }
   ```
   
   ```
   public E get(int index) {
           return get(getArray(), index); //直接从当前的数组中返回
       }
  
   ```
   
   
#### HashSet、TreeSet -> CopyOnWriteArraySet、ConcurrentSkipListSet（线程安全部分）
   - CopyOnWriteArraySet 底层是通过CopyOnWriteArrayList实现的，唯一的判断过程如下源码：
   ```
    public boolean addIfAbsent(E e) {
           Object[] snapshot = getArray(); //获得当前的数据
           return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :
               addIfAbsent(e, snapshot);
       }
       
    /***
      1 . 循环查询数组中是否与此对象一致的对象。注意：如果对象需要重写equals方法
      2 . 没有则添加
    ***/
    private static int indexOf(Object o, Object[] elements,
                                   int index, int fence) {
            if (o == null) {
                for (int i = index; i < fence; i++)
                    if (elements[i] == null)
                        return i;
            } else {
                for (int i = index; i < fence; i++)
                    if (o.equals(elements[i]))
                        return i;
            }
            return -1;
        }
     
     /**
       1. 会判断当前的数组有没有被修改，没有则直接创建一个比当前容器大一的容器，赋值，重定引用
       2. 如果已被修改判断是否是新增成功，如果已经执行则返回false，如果容器被其他操作执行，检查当前容器中是否已存在当前值。
     ***/
     private boolean addIfAbsent(E e, Object[] snapshot) {
            final ReentrantLock lock = this.lock;
            lock.lock();
            try {
                Object[] current = getArray();
                int len = current.length;
                if (snapshot != current) {
                    // Optimize for lost race to another addXXX operation
                    int common = Math.min(snapshot.length, len);
                    for (int i = 0; i < common; i++)
                        if (current[i] != snapshot[i] && eq(e, current[i]))
                            return false;
                    if (indexOf(e, current, common, len) >= 0)
                            return false;
                }
                Object[] newElements = Arrays.copyOf(current, len + 1);
                newElements[len] = e;
                setArray(newElements);
                return true;
            } finally {
                lock.unlock();
            }
        }
   ```
   - ConcurrentSkipListSet 的底层实现为ConcurrentSkipListMap
   
#### HashMap、TreeMap -> ConcurrentHashMap、ConcurrentSkipListMap
   
#### AQS(AbstractQueuedSynchronizer 抽象类)核心

- 基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架
- 该同步器（以下简称同步器）利用了一个int来表示状态
- 此子类对于状态的把握，需要使用这个同步器提供的以下三个方法对状态进行操作：
  ```
  java.util.concurrent.locks.AbstractQueuedSynchronizer.getState()
    java.util.concurrent.locks.AbstractQueuedSynchronizer.setState(int)
    java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(int, int)
  ```
- 该同步器即可以作为排他模式也可以作为共享模式，当它被定义为一个排他模式时，其他线程对其的获取就被阻止，而共享模式对于多个线程获取都可以成功
  
  思路：
    
    

    
    

    
##### CountDownLatch
```
public static void main(String[] args) {
		final CountDownLatch countDownLatch = new CountDownLatch(2);
		
		ExecutorService service = Executors.newCachedThreadPool();

		for(int i = 0;i < 5;i++){
			service.execute(()->{
				try {
					Thread.sleep((int)Math.random()*1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				log.info(" 线程id为： {}",Thread.currentThread().getId());
				countDownLatch.countDown();
			});
		}

		try {
			countDownLatch.await();
			/**
			 * 等待时间，如果任务10秒内没有完成，则不再关心。
			 */
			//countDownLatch.await(10, TimeUnit.SECONDS);
			log.info("ok");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		service.shutdown();
	}
```
 上面的案例说明，将有五个子任务需要执行，但是需要前两个先执行，等执行完后，后面的才会执行。
 

##### Semaphore 信号量

   - 控制访问数量
   Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。
   ```
   @Slf4j
   public class SemaphoreExample {
   
   
   	public static void main(String[] args) {
   		final Semaphore semaphore = new Semaphore(1);
   
   		ExecutorService service = Executors.newCachedThreadPool();
   
   		for(int i = 0;i < 10;i ++){
   			service.execute(()->{
   				try {
   					semaphore.acquire();
                       Thread.sleep(1000);
   					log.info("信号量执行id： {}",Thread.currentThread().getId());
   					semaphore.release();
   				} catch (InterruptedException e) {
   					e.printStackTrace();
   				}
   			});
   		}
   	}
   }
   ```
   
##### CyclicBarrier
  字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了
  
  下面举几个例子就明白了：
  
  　　假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了：
  ```
  public class Test {
      public static void main(String[] args) {
          int N = 4;
          CyclicBarrier barrier  = new CyclicBarrier(N);
          for(int i=0;i<N;i++)
              new Writer(barrier).start();
      }
      static class Writer extends Thread{
          private CyclicBarrier cyclicBarrier;
          public Writer(CyclicBarrier cyclicBarrier) {
              this.cyclicBarrier = cyclicBarrier;
          }
   
          @Override
          public void run() {
              System.out.println("线程"+Thread.currentThread().getName()+"正在写入数据...");
              try {
                  Thread.sleep(5000);      //以睡眠来模拟写入数据操作
                  System.out.println("线程"+Thread.currentThread().getName()+"写入数据完毕，等待其他线程写入完毕");
                  cyclicBarrier.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }catch(BrokenBarrierException e){
                  e.printStackTrace();
              }
              System.out.println("所有线程写入完毕，继续处理其他任务...");
          }
      }
  }
  
  线程Thread-0正在写入数据...
  线程Thread-3正在写入数据...
  线程Thread-2正在写入数据...
  线程Thread-1正在写入数据...
  线程Thread-2写入数据完毕，等待其他线程写入完毕
  线程Thread-0写入数据完毕，等待其他线程写入完毕
  线程Thread-3写入数据完毕，等待其他线程写入完毕
  线程Thread-1写入数据完毕，等待其他线程写入完毕
  所有线程写入完毕，继续处理其他任务...
  所有线程写入完毕，继续处理其他任务...
  所有线程写入完毕，继续处理其他任务...
  所有线程写入完毕，继续处理其他任务...
  ```
 
   
   
下面对上面说的三个辅助类进行一个总结：

　　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：

　　　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；

　　　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；

　　　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。

　　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。


参考：https://www.cnblogs.com/dolphin0520/p/3920397.html

#### ReentrantLock 与锁

   - 与synchronized区别
    + 可重入性
    + 锁的实现
    + 性能的区别
    + 功能区别
   - 独有功能
    + 可指定公平锁还是非公平锁
    + 提供一个Condition类，可以分组唤醒需要唤醒的线程
    + 提供能够中断等待锁的线程的机制，lock.lockInterruptibly()
    
    https://www.jianshu.com/p/d1cee89c1dda
    
#### FutureTask

#### ForkJoin

#### BlockingQueue

#### 线程池

#### threadLocal

#### hashMap(多线程下的死循环)与ConcurrentHashMap
    
    